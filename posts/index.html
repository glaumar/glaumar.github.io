<!doctype html><html lang=en><meta charset=utf-8><meta name=generator content="Hugo 0.83.1"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><title>Posts&nbsp;&ndash;&nbsp;Glaumar's Blog</title><link rel=stylesheet href=/css/core.min.78719e8336f9f7af67a9d03a6d2bcd57bbe5df387d3b75b34078aaa427279d260421eebb4123000aba27599bfce6538c.css integrity=sha384-eHGegzb5969nqdA6bSvNV7vl3zh9O3WzQHiqpCcnnSYEIe67QSMACronWZv85lOM><link rel=alternate type=application/rss+xml href=/posts/index.xml title="Glaumar's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><body><section id=header><div class="header wrap"><span class="header left-side"><a class="site home" href=/><span class="site name">Glaumar's Blog</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class="nav item" href=/categories/>Categories</a><a class="nav item" href=/tags/>Tags</a><a class="nav item" href=/about>About</a></nav></div></span></div><div class="site slogan"><span class=title>#! /because/we/can</span></div></section><section id=content><section class="article header"><h1>Posts</h1></section><ul class="note list"><li class=item><a class=note href=/posts/toml/><p class="note title">TOML</p><p class="note date">Monday, May 24, 2021</p><p class="note content">基本语法 键值对 布尔值 整数 浮点数 时间 字符串 数组 表 表数组 “TOML”是“Tom&rsquo;s Obvious, Minimal Language“的缩写，文件扩展名为.tom<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=category href=/categories/memo/>memo</a><a class=tag href=/tags/toml/>toml</a></p></li><li class=item><a class=note href=/posts/yaml/><p class="note title">YAML</p><p class="note date">Sunday, May 23, 2021</p><p class="note content">基本语法 对象 数组 混合使用 基本类型 强制类型转换 多行字符串 引用 YAML是“YAML Ain’t Markup Language”的递归缩写。扩展名可以是.yam<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=category href=/categories/memo/>memo</a><a class=tag href=/tags/yaml/>yaml</a></p></li><li class=item><a class=note href=/posts/git/><p class="note title">Git</p><p class="note date">Saturday, May 22, 2021</p><p class="note content">配置（config） 克隆（clone） 子仓库（submodule） 暂存（staged） 提交（commit） 分支（branch） 贮藏（stas<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=category href=/categories/memo/>memo</a><a class=tag href=/tags/git/>git</a></p></li><li class=item><a class=note href=/posts/compare-float-values/><p class="note title">浮点数比较</p><p class="note date">Tuesday, August 18, 2020</p><p class="note content">计算机中的浮点数并不精确, 不能直接用 == 比较两个浮点数是否相等, 应在可接受的范围定义一个比较小的数 epsilon , 两个浮点数之差小于 epsilon 即认为他们相等 C #include &lt;float.h>#include<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/c/>c</a><a class=tag href=/tags/cpp/>cpp</a><a class=tag href=/tags/qt/>qt</a><a class=tag href=/tags/js/>js</a><a class=tag href=/tags/algorithm/>algorithm</a></p></li><li class=item><a class=note href=/posts/sleep-for-and-chrono-duration/><p class="note title">this_thread::sleep_for()和chrono::duration, ratio;</p><p class="note date">Friday, August 14, 2020</p><p class="note content">想着找个跨平台的 sleep() , 看到了标准库里的 sleep_for() , 用起来不难, 但涉及到一些没见过的类 TL;DR C++11 using namespace std; this_thread::sleep_for(chrono::milliseconds(500)); this_thread::sleep_for(chrono::seconds(2)); this_thread::sleep_for(chrono::minutes(1)); C++14 using namespace std; using namespace std::chrono_literals; this_thread::sleep_for(500ms); this_thread::sleep_for(2s); this_thread::sleep_for(1min); std::this_thread::sleep_for header: &lt;thread> template&lt; class Rep, class Period > void sleep_for( const std::chrono::duration&lt;Rep, Period>& sleep_duration<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/cpp/>cpp</a></p></li><li class=item><a class=note href=/posts/image-rounded-corners-in-qml/><p class="note title">QML实现图片圆角</p><p class="note date">Saturday, July 4, 2020</p><p class="note content">QML中的 Image 类型没有 radius 属性，不像 Rectangle 可以自定义圆角，借助 OpacityMask （需要导入 QtGraphicalEffects ）把他们结合到一起即可实现图片圆角 import QtQuick 2.15 import QtQuick.Controls 2.15 import QtGraphicalEffects 1.15 ApplicationWindow { id: window visible: true width: 640 height: 480<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/qml/>qml</a><a class=tag href=/tags/qt/>qt</a></p></li><li class=item><a class=note href=/posts/center-block-but-align-contents-to-the-left/><p class="note title">Div+CSS实现文本居中左对齐</p><p class="note date">Monday, June 15, 2020</p><p class="note content">&lt;div style="text-align: center;"> &lt;div style="display: inline-block; text-align: left;"> &lt;p>&lt;b>学院：&lt;/b>&lt;u>信息科学与工程&lt;/u>&lt;/<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/html/>html</a><a class=tag href=/tags/css/>css</a></p></li><li class=item><a class=note href=/posts/generate-random-number-using-stl/><p class="note title">使用STL生成随机数</p><p class="note date">Monday, June 15, 2020</p><p class="note content">随机数种子 使用随机数引擎生成（伪）随机数前，我们通常需要传入一个种子以确保程序每次运行能生成不同的随机数 random_device 类可以使用系统提供的数据源，并返回<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/cpp/>cpp</a></p></li><li class=item><a class=note href=/posts/the-difference-between-++i-and-i++-in-cpp/><p class="note title">c++中++i和i++的区别</p><p class="note date">Saturday, June 6, 2020</p><p class="note content">1. 计算顺序不同 i++ 返回 i 本身，然后将 i 加一 ++i 将 i 加一，然后返回 i int i = 0; std::cout &lt;&lt; i++ &lt;&lt; " " &lt;&lt; i; std::cout &lt;&lt; std::endl; std::cout &lt;&lt; ++i &lt;&lt; " " &lt;&lt; i; output： 0 1 2 2 2. 返回值性<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/cpp/>cpp</a></p></li><li class=item><a class=note href=/posts/non-recursive-traversal-of-binary-tree/><p class="note title">非递归遍历二叉树</p><p class="note date">Saturday, May 23, 2020</p><p class="note content">二叉树的非递归遍历基于栈， 代码风格不像递归遍历那么简洁统一，不太好记，聊以备忘 代码来自 这篇文章 ，作者在文章中统一了三种非递归遍历的风格，对于<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/algorithm/>algorithm</a></p></li></ul><div class=pagination><ul><li><a class=active href=/posts/>1</a></li><li><a href=/posts/page/2/>2</a></li><li><a href=/posts/page/3/>3</a></li></ul></div></section><section id=footer><div class=footer-wrap><p class=copyright>©2021 glaumar.</p><p class=powerby><span>Powered&nbsp;by&nbsp;</span><a href=https://gohugo.io target=_blank rel="noopener noreferrer">Hugo</a><span>&nbsp;&&nbsp;</span><a href=https://themes.gohugo.io/hugo-notepadium/ target=_blank rel="noopener noreferrer">Notepadium</a></p></div></section></body></html>