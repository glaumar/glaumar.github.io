<!doctype html><html lang=en><meta charset=utf-8><meta name=generator content="Hugo 0.83.1"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><title>algorithm&nbsp;&ndash;&nbsp;Glaumar's Blog</title><link rel=stylesheet href=/css/core.min.78719e8336f9f7af67a9d03a6d2bcd57bbe5df387d3b75b34078aaa427279d260421eebb4123000aba27599bfce6538c.css integrity=sha384-eHGegzb5969nqdA6bSvNV7vl3zh9O3WzQHiqpCcnnSYEIe67QSMACronWZv85lOM><link rel=alternate type=application/rss+xml href=/tags/algorithm/index.xml title="Glaumar's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="algorithm"><body><section id=header><div class="header wrap"><span class="header left-side"><a class="site home" href=/><span class="site name">Glaumar's Blog</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class="nav item" href=/categories/>Categories</a><a class="nav item" href=/tags/>Tags</a><a class="nav item" href=/about>About</a></nav></div></span></div><div class="site slogan"><span class=title>#! /because/we/can</span></div></section><section id=content><section class="article header"><h1>algorithm</h1></section><ul class="note list"><li class=item><a class=note href=/posts/compare-float-values/><p class="note title">浮点数比较</p><p class="note date">Tuesday, August 18, 2020</p><p class="note content">计算机中的浮点数并不精确, 不能直接用 == 比较两个浮点数是否相等, 应在可接受的范围定义一个比较小的数 epsilon , 两个浮点数之差小于 epsilon 即认为他们相等 C #include &lt;float.h>#include<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/c/>c</a><a class=tag href=/tags/cpp/>cpp</a><a class=tag href=/tags/qt/>qt</a><a class=tag href=/tags/js/>js</a><a class=tag href=/tags/algorithm/>algorithm</a></p></li><li class=item><a class=note href=/posts/non-recursive-traversal-of-binary-tree/><p class="note title">非递归遍历二叉树</p><p class="note date">Saturday, May 23, 2020</p><p class="note content">二叉树的非递归遍历基于栈， 代码风格不像递归遍历那么简洁统一，不太好记，聊以备忘 代码来自 这篇文章 ，作者在文章中统一了三种非递归遍历的风格，对于<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/algorithm/>algorithm</a></p></li><li class=item><a class=note href=/posts/rpn-and-shunting-yard/><p class="note title">逆波兰表达式和调度场算法</p><p class="note date">Friday, April 17, 2020</p><p class="note content">逆波兰表达式 逆波兰表达式也叫后缀表达式，而我们平常使用的则是中缀表达式 中缀表达式 后缀表达式 1+2 12+ 1+2+3 12+3+ 1+2*3 123*+ 3^3^3 333^^ 中缀表达符合人的思维和习惯，方便人<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/algorithm/>algorithm</a></p></li></ul></section><section id=footer><div class=footer-wrap><p class=copyright>©2021 glaumar.</p><p class=powerby><span>Powered&nbsp;by&nbsp;</span><a href=https://gohugo.io target=_blank rel="noopener noreferrer">Hugo</a><span>&nbsp;&&nbsp;</span><a href=https://themes.gohugo.io/hugo-notepadium/ target=_blank rel="noopener noreferrer">Notepadium</a></p></div></section></body></html>