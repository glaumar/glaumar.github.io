<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.83.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Glaumar&#39;s Blog&nbsp;&ndash;&nbsp;#! /because/we/can</title><link rel="stylesheet" href="/css/core.min.78719e8336f9f7af67a9d03a6d2bcd57bbe5df387d3b75b34078aaa427279d260421eebb4123000aba27599bfce6538c.css" integrity="sha384-eHGegzb5969nqdA6bSvNV7vl3zh9O3WzQHiqpCcnnSYEIe67QSMACronWZv85lOM"><link rel="alternate" type="application/rss+xml" href="/index.xml" title="Glaumar's Blog" /><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Glaumar&#39;s Blog" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">Glaumar's Blog</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/about">About</a></nav></div></span></div><div class="site slogan"><span class="title">#! /because/we/can</span></div></section><section id="content"><ul class="note list"><li class="item"><a class="note" href="/posts/compare-float-values/">
            <p class="note title">浮点数比较</p><p class="note date">Tuesday, August 18, 2020</p><p class="note content">计算机中的浮点数并不精确, 不能直接用 == 比较两个浮点数是否相等, 应在可接受的范围定义一个比较小的数 epsilon , 两个浮点数之差小于 epsilon 即认为他们相等 C #include &lt;float.h&gt;#include<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/c/">c</a><a class="tag" href="/tags/cpp/">cpp</a><a class="tag" href="/tags/qt/">qt</a><a class="tag" href="/tags/js/">js</a><a class="tag" href="/tags/algorithm/">algorithm</a></p></li><li class="item"><a class="note" href="/posts/sleep-for-and-chrono-duration/">
            <p class="note title">this_thread::sleep_for()和chrono::duration, ratio;</p><p class="note date">Friday, August 14, 2020</p><p class="note content">想着找个跨平台的 sleep() , 看到了标准库里的 sleep_for() , 用起来不难, 但涉及到一些没见过的类 TL;DR C++11 using namespace std; this_thread::sleep_for(chrono::milliseconds(500)); this_thread::sleep_for(chrono::seconds(2)); this_thread::sleep_for(chrono::minutes(1)); C++14 using namespace std; using namespace std::chrono_literals; this_thread::sleep_for(500ms); this_thread::sleep_for(2s); this_thread::sleep_for(1min); std::this_thread::sleep_for header: &lt;thread&gt; template&lt; class Rep, class Period &gt; void sleep_for( const std::chrono::duration&lt;Rep, Period&gt;&amp; sleep_duration<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/cpp/">cpp</a></p></li><li class="item"><a class="note" href="/posts/image-rounded-corners-in-qml/">
            <p class="note title">QML实现图片圆角</p><p class="note date">Saturday, July 4, 2020</p><p class="note content">QML中的 Image 类型没有 radius 属性，不像 Rectangle 可以自定义圆角，借助 OpacityMask （需要导入 QtGraphicalEffects ）把他们结合到一起即可实现图片圆角 import QtQuick 2.15 import QtQuick.Controls 2.15 import QtGraphicalEffects 1.15 ApplicationWindow { id: window visible: true width: 640 height: 480<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/qml/">qml</a><a class="tag" href="/tags/qt/">qt</a></p></li><li class="item"><a class="note" href="/posts/center-block-but-align-contents-to-the-left/">
            <p class="note title">Div+CSS实现文本居中左对齐</p><p class="note date">Monday, June 15, 2020</p><p class="note content">&lt;div style=&#34;text-align: center;&#34;&gt; &lt;div style=&#34;display: inline-block; text-align: left;&#34;&gt; &lt;p&gt;&lt;b&gt;学院：&lt;/b&gt;&lt;u&gt;信息科学与工程&lt;/u&gt;&lt;/<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/html/">html</a><a class="tag" href="/tags/css/">css</a></p></li><li class="item"><a class="note" href="/posts/generate-random-number-using-stl/">
            <p class="note title">使用STL生成随机数</p><p class="note date">Monday, June 15, 2020</p><p class="note content">随机数种子 使用随机数引擎生成（伪）随机数前，我们通常需要传入一个种子以确保程序每次运行能生成不同的随机数 random_device 类可以使用系统提供的数据源，并返回<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/cpp/">cpp</a></p></li><li class="item"><a class="note" href="/posts/the-difference-between-&#43;&#43;i-and-i&#43;&#43;-in-cpp/">
            <p class="note title">c++中++i和i++的区别</p><p class="note date">Saturday, June 6, 2020</p><p class="note content">1. 计算顺序不同 i++ 返回 i 本身，然后将 i 加一 ++i 将 i 加一，然后返回 i int i = 0; std::cout &lt;&lt; i++ &lt;&lt; &#34; &#34; &lt;&lt; i; std::cout &lt;&lt; std::endl; std::cout &lt;&lt; ++i &lt;&lt; &#34; &#34; &lt;&lt; i; output： 0 1 2 2 2. 返回值性<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/cpp/">cpp</a></p></li><li class="item"><a class="note" href="/posts/non-recursive-traversal-of-binary-tree/">
            <p class="note title">非递归遍历二叉树</p><p class="note date">Saturday, May 23, 2020</p><p class="note content">二叉树的非递归遍历基于栈， 代码风格不像递归遍历那么简洁统一，不太好记，聊以备忘 代码来自 这篇文章 ，作者在文章中统一了三种非递归遍历的风格，对于<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/algorithm/">algorithm</a></p></li><li class="item"><a class="note" href="/posts/suid-sgid-and-sbit/">
            <p class="note title">SUID、SGID 和 SBIT</p><p class="note date">Saturday, May 16, 2020</p><p class="note content">SUID SGID SBIT 全称 set UID set GID Sticky Bit 解释 s标志出现在文件拥有者的x权限位置上 ：-rwsr-xr-x s标志出现在文件群组的x权限位置：-rwxr-sr-x t<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/linux/">linux</a></p></li><li class="item"><a class="note" href="/posts/convert-dos-file-to-unix-format/">
            <p class="note title">将windows文本文件转换为linux格式</p><p class="note date">Wednesday, May 6, 2020</p><p class="note content">中文环境下，在Windows和Linux下创建的文本文件主要区别有两个 Windows行尾为 \r\n ，Linux行尾为 \n Windows下中文使用GB<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/linux/">linux</a></p></li><li class="item"><a class="note" href="/posts/lua-modulo-and-math_fmod/">
            <p class="note title">C 和 Lua 取模运算的异同</p><p class="note date">Saturday, May 2, 2020</p><p class="note content">C 取模 C语言的取模运算符（%）仅支持整数，定义如下： a % b == a - ((a / b) * b) 对于 a/b ， C语言会自动截断计算结果的小数部分， C99规定了&quot<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/lua/">lua</a><a class="tag" href="/tags/c/">c</a></p></li></ul><div class="pagination">
    <ul><li><a class="active" href="/">1</a></li><li><a class="" href="/page/2/">2</a></li><li><a class="" href="/page/3/">3</a></li></ul>
</div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">©2021 glaumar.</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div>
</section></body>

</html>